theme = "ayu_mirage"
# theme = "catppuccin_macchiato"
# theme = "gruvbox_dark_hard"

[editor]
rulers = [80, 100]
cursorline = true
color-modes = true
true-color = true
line-number = "relative"
shell = ["nu", "-c"]
jump-label-alphabet = "smtneriacgwlypfouqjvdhbxkz"
end-of-line-diagnostics = "disable"
# This was previously disabled
# since I can't build from source on my work PC,
# but thankfully,
# I can just copy the .exe and grammars
# over on a thumb drive
rainbow-brackets = true # Disabled since it currently requires building from source.
# shell = ["powershell", "-NoProfile", "-Command"]

[editor.cursor-shape]
insert = "bar"
normal = "block"
select = "underline"

# I don't code basically ever,
# so I don't need complex features.
[editor.statusline]
left = ["mode", "spinner", "file-name"]
center = [
  "read-only-indicator",
  "file-modification-indicator",
  "selections",
  "position",
  "file-type",
]
right = ["diagnostics", "file-encoding", "file-line-ending"]
separator = "│"
diagnostics = ["warning", "error", "hint"]
mode.normal = "NORMAL"
mode.insert = "INSERT"
mode.select = "EXTEND"

[editor.indent-guides]
render = true
character = "⸽"

[editor.whitespace]
render.newline = "all"
characters.newline = "⏎"

[editor.soft-wrap]
enable = true
# I decided to go with unmarked soft wrap
# because even though I use semantic linefeeds,
# a lot of documents are not written with that in mind.
# We also don't have terminal restrictions like we used to,
# at least none that I'd come up against.
wrap-indicator = ""

[editor.inline-diagnostics]
other-lines = "disable"
cursor-line = "warning"

[editor.smart-tab]
enable = false

[keys.normal]
# Quick iteration on config changes.
C-o = ":config-open"
C-r = ":config-reload"

# Movement keymaps.
H = "move_prev_sub_word_start"
L = "move_next_sub_word_start"
"{" = ["goto_prev_paragraph", "collapse_selection"]
"}" = ["goto_next_paragraph", "collapse_selection"]
# More ergonomic than <gw>,
# especially in my Night keyboard layout.
ret = "goto_word"

# Escape madness easily.
esc = ["collapse_selection", "keep_primary_selection"]

# Allows adding newlines easier.
o = ["open_below", "normal_mode"]
O = ["open_above", "normal_mode"]
 
# Moving things to next line;
# useful for semantic linefeeds.
q = ["move_prev_word_start", "insert_newline"]
Q = ["move_prev_long_word_start", "insert_newline"]
J = ["join_selections_space"]

# Remapping macros to facilitate the above
# since I very, very rarely use macros.
C-q = "record_macro"
A-q = "replay_macro"

# Helix should have this by default
X = "select_line_above"

# Allows selecting line without whitespace
A-x = ["extend_line_below", "trim_selections"]

# Allows trimming the selection easier.
"-" = "trim_selections"

# Allow moving lines up and down
"A-j" = [
  "extend_to_line_bounds",
  "delete_selection",
  "paste_after"
]
"A-k" = [
  "extend_to_line_bounds",
  "delete_selection",
  "move_line_up",
  "paste_before",
]


# Configuration to use yazi as file manager
# compatible with Windows + Nushell,
# my current use case.
C-y = [
  ':sh rm --force C:\temp\unique-file',
  ':insert-output yazi.exe %{buffer_name} --chooser-file=C:\temp\unique-file',
  ':open %sh{open --raw C:\temp\unique-file}',
  ":redraw",
  ":reload-all"
]

# Match in next instance of pair
[keys.normal.m.n]
"(" = "@s\\(<ret>nmim"
"{" = "@s\\{<ret>nmim"
"[" = "@s\\[<ret>nmim"
'"' = '@s\"<ret>nmim'
"'" = "@s\\'<ret>nmim"
"<" = "@s<lt><ret>nmim"

# Match in previous instance of pair
[keys.normal.m.p]
"(" = "@s\\)<ret>Nmmmim"
"{" = "@s\\}<ret>Nmmmim"
"[" = "@s\\]<ret>Nmmmim"
'"' = '@s\"<ret>Nmmmim'
"'" = "@s\\'<ret>Nmmmim"
"<" = "@s<gt><ret>Nmmmim"

[keys.normal.Z]
# Since I use callum-style mods,
# having to hold down Ctrl and repeatedly press letters
# is literally impossible.
# This rebinding lets me more easily browse a file
# without using a modifier.
b = "page_up"
f = "page_down"
u = "page_cursor_half_up"
d = "page_cursor_half_down"

# From helix-vim
Z = ":wq"

# # Commands designed to work with my `zettel-cli` program
# [keys.normal."space".z]
# # Generate sibling note (no open)
# s = ":sh zettel id parse %{buffer_name} | zettel id next-sibling | zettel note create"
# # Generate child note (no open)
# c = ":sh zettel id parse %{buffer_name} | zettel id next-child | zettel note create"
# # Search vault for selection and print results into buffer
# f = ":append-output zettel search %{selection}"
 
[keys.select]
# Allow selecting paragraphs, finally.
"{" = ["extend_to_line_bounds", "goto_prev_paragraph"]
"}" = ["extend_to_line_bounds", "goto_next_paragraph"]

# Allows trimming the selection easier.
"-" = "trim_selections"

[keys.insert]
# Makes word deletes from other programs work here.
"C-backspace" = "delete_word_backward"
"C-del" = "delete_word_forward"
